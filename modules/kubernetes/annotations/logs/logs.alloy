
declare "pods" {
  // arguments for kubernetes discovery
  argument "namespaces" {
    comment = "The namespaces to look for targets in (default: [\"kube-system\"] is all namespaces)"
    optional = true
  }

  argument "field_selectors" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    comment = "The label selectors to use to find matching targets (default: [])"
    optional = true
  }

  argument "label_selectors" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    comment = "The label selectors to use to find matching targets (default: [\"k8s-app=konnectivity-agent\"])"
    optional = true
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: metrics.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "tenant" {
    comment = "The tenant to write metrics to.  This does not have to be the tenantId, this is the value to look for in the logs.agent.grafana.com/tenant annotation, and this can be a regex."
    optional = true
    default = ".*"
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  // export the discovered targets
  export "output" {
    value = discovery.relabel.log_annotations.output
  }

  // export the annotation argument
  export "annotation" {
    value = coalesce(argument.annotation.value, "logs.grafana.com")
  }

  // find all pods
  discovery.kubernetes "log_annotations" {
    role = "pod"

    selectors {
      role = "pod"
      field = join(coalesce(argument.field_selectors.value, []), ",")
      label = join(coalesce(argument.label_selectors.value, []), ",")
    }

    namespaces {
      names = coalesce(argument.namespaces.value, [])
    }
  }

  // apply relabelings
  discovery.relabel "log_annotations" {
    targets = discovery.kubernetes.log_annotations.targets

    // allow pods to declare their logs to be ingested or not, the default is true
    //   i.e. logs.grafana.com/ingest: false
    rule {
      action = "keep"
      source_labels = [
        "__meta_kubernetes_pod_annotation_" + argument.__sd_annotation.value + "_ingest",
      ]
      regex = "^(true|)$"
    }

    // allow pods to declare what tenant their logs should be written to, the following annotation is supported:
    //   logs.grafana.com/tenant: "primary"
    rule {
      action = "keep"
      source_labels = [
        "__meta_kubernetes_pod_annotation_" + argument.__sd_annotation.value + "_ingest",
      ]
      regex = "^(" + argument.tenant.value + ")$"
    }

    // set the instance label as the name of the worker node the pod is on
    rule {
      action = "replace"
      source_labels = ["__meta_kubernetes_pod_node_name"]
      target_label = "instance"
    }

    // set the namespace label
    rule {
      source_labels = ["__meta_kubernetes_namespace"]
      target_label  = "namespace"
    }

    // set the pod label
    rule {
      source_labels = ["__meta_kubernetes_pod_name"]
      target_label  = "pod"
    }

    // set the container label
    rule {
      source_labels = ["__meta_kubernetes_pod_container_name"]
      target_label  = "container"
    }

    // set a workload label
    rule {
      source_labels = [
        "__meta_kubernetes_pod_controller_kind",
        "__meta_kubernetes_pod_controller_name",
      ]
      separator = "/"
      target_label  = "workload"
    }
    // remove the hash from the ReplicaSet
    rule {
      source_labels = ["workload"]
      regex = "(ReplicaSet/.+)-.+"
      target_label  = "workload"
    }

    // set the app name if specified as metadata labels "app:" or "app.kubernetes.io/name:" or "k8s-app:"
    rule {
      action = "replace"
      source_labels = [
        "__meta_kubernetes_pod_label_app_kubernetes_io_name",
        "__meta_kubernetes_pod_label_k8s_app",
        "__meta_kubernetes_pod_label_app",
      ]
      separator = ";"
      regex = "^(?:;*)?([^;]+).*$"
      replacement = "$1"
      target_label = "app"
    }

    // set the component if specified as metadata labels "component:" or "app.kubernetes.io/component:" or "k8s-component:"
    rule {
      action = "replace"
      source_labels = [
        "__meta_kubernetes_pod_label_app_kubernetes_io_component",
        "__meta_kubernetes_pod_label_k8s_component",
        "__meta_kubernetes_pod_label_component",
      ]
      regex = "^(?:;*)?([^;]+).*$"
      replacement = "$1"
      target_label = "component"
    }

    // set the version if specified as metadata labels "version:" or "app.kubernetes.io/version:" or "app_version:"
    rule {
      action = "replace"
      source_labels = [
        "__meta_kubernetes_pod_label_app_kubernetes_io_version",
        "__meta_kubernetes_pod_label_version",
        "__meta_kubernetes_pod_label_app_version",
      ]
      regex = "^(?:;*)?([^;]+).*$"
      replacement = "$1"
      target_label = "version"
    }

    // set a source label
    rule {
      action = "replace"
      replacement = "kubernetes"
      target_label = "source"
    }

    // set the job label to be namespace / friendly pod name
    rule {
      action = "replace"
      source_labels = [
        "workload",
        "__meta_kubernetes_namespace",
      ]
      regex = ".+\\/(.+);(.+)"
      replacement = "$2/$1"
      target_label = "job"
    }
  }

}

declare "drop_levels" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "trace_value" {
    comment = "The regular expression to use to determine if trace logs should be dropped, if you want to drop trace by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  argument "debug_value" {
    comment = "The regular expression to use to determine if debug logs should be dropped, if you want to drop debug by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  argument "info_value" {
    comment = "The regular expression to use to determine if info logs should be dropped, if you want to drop info by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  argument "trace_level" {
    comment = "The regular expression to use to match trace logs level label value (default: (?i)(trace?|trc))"
    default = "(?i)(trace?|trc)"
    optional = true
  }

  argument "debug_level" {
    comment = "The regular expression to use to match debug logs level label value (default: (?i)(debug?|dbg))"
    default = "(?i)(debug?|dbg)"
    optional = true
  }

  argument "info_level" {
    comment = "The regular expression to use to match info logs level label value (default: (?i)(info?))"
    default = "(?i)(info?)"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "receiver" {
    value = loki.process.drop_level.receiver
  }

  loki.process "drop_level" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/drop-trace annotation, if not set or set to true then drop
    // any log message with level=trace
    stage.match {
      pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-trace: true"
      selector = "{" + argument.__sd_annotation.value + "_drop_trace=~\"" + argument.trace_value.value + "\"" + ",level=~\"" + argument.trace_level.value + "\"}"
      action = "drop"
      drop_counter_reason = "trace"
    }

    // check logs.grafana.com/drop-debug annotation, if not set or set to true then drop
    // any log message with level=debug
    stage.match {
      pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-debug: true"
      selector = "{" + argument.__sd_annotation.value + "_drop_debug=~\"" + argument.debug_value.value + "\"" + ",level=~\"" + argument.debug_level.value + "\"}"
      action = "drop"
      drop_counter_reason = "debug"
    }

    // check logs.grafana.com/drop-info annotation, if not set or set to true then drop
    // any log message with level=info
    stage.match {
      pipeline_name = "pipeline for annotation ||" + argument.annotation.value + "/drop-info: true"
      selector = "{" + argument.__sd_annotation.value + "_drop_trace=~\"" + argument.info_value.value + "\"" + ",level=~\"" + argument.info_level.value + "\"}"
      action = "drop"
      drop_counter_reason = "info"
    }

  }
}

declare "decolorize" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "decolorize_value" {
    comment = "The regular expression to use to determine if logs should be decolorized, if you want to decolorize by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.decolorize.receiver
  }

  loki.process "decolorize" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/drop-trace annotation, if not set or set to true then drop
    // any log message with level=trace
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_decolorize=~\"" + argument.decolorize_value.value + "\"}"

      stage.decolorize {}
    }

  }
}

declare "json_scrub_empties" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "scrub_empties_value" {
    comment = "The regular expression to use to determine if logs should have json empties scrubbed, if you want to scrub empties by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.json_scrub_empties.receiver
  }

  loki.process "json_scrub_empties" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/scrub-empties annotation, if true remove any json property whose value is set to
    // an empty string "", empty object {} or empty array [] is removed
    // this can reduce the overall # of bytes sent and stored in Loki
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_scrub_empties=~\"" + argument.scrub_empties_value.value + "\"} |~ \"^\\s*{(.|\n)+}\\s*$\""

      // remove null properties
      stage.replace {
        // unescaped regex: (\s*,\s*("[^"]+"\s*:\s*(\[\s*\]|\{\s*\}|"\s*"))|("[^"]+"\s*:\s*(\[\s*\]|\{\s*\}|"\s*"))\s*,\s*)
        expression = "(\\s*,\\s*(\"[^\"]+\"\\s*:\\s*(\\[\\s*\\]|\\{\\s*\\}|\"\\s*\"))|(\"[^\"]+\"\\s*:\\s*(\\[\\s*\\]|\\{\\s*\\}|\"\\s*\"))\\s*,\\s*)"
        replace = ""
      }
    }

  }
}

declare "json_scrub_nulls" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "scrub_nulls_value" {
    comment = "The regular expression to use to determine if logs should have json nulls scrubbed, if you want to scrub nulls by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.json_scrub_empties.receiver
  }

  loki.process "json_scrub_nulls" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/scrub-empties annotation, if true remove any json property whose value is set to
    // an empty string "", empty object {} or empty array [] is removed
    // this can reduce the overall # of bytes sent and stored in Loki
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_scrub_nulls=~\"" + argument.scrub_nulls_value.value + "\"} |~ \"^\\s*{(.|\n)+}\\s*$\""

      // remove null properties
      stage.replace {
        // unescaped regex: (\s*,\s*("[^"]+"\s*:\s*null)|("[^"]+"\s*:\s*null)\s*,\s*)
        expression = "(\\s*,\\s*(\"[^\"]+\"\\s*:\\s*null)|(\"[^\"]+\"\\s*:\\s*null)\\s*,\\s*)"
        replace = ""
      }
    }

  }
}

declare "embed_pod" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "embed_pod_value" {
    comment = "The regular expression to use to determine if pod should be embedded or not, if you want to embed the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  argument "embed_pod_key" {
    comment = "The key to use to embed the pod name into the log message (default: __pod)"
    default = "__pod"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.embed_pod.receiver
  }

  loki.process "embed_pod" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/embed-pod annotation, if true embed the name of the pod to the end of the log line
    // this can reduce the overall cardinality, by not using a label of "pod", individual pods can still be searched
    // using a line selector i.e. __pod=your-pod-name
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/embed-pod: true"

      // embed as json property
      stage.match {
        selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"} |~ \"^\\s*{(.|\n)+}\\s*$\""
        // render a new label called log_line, and add the name of the pod to the end of the log message
        // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
        // to the high cardinality it would create.
        // note: .Entry is a special key that is used to reference the current line
        stage.replace {
          expression = "\\}$"
          replace = ""
        }
        stage.template {
          source = "log_line"
          template = "{{ .Entry }},\"" + argument.embed_pod_key.value + "\":\"{{ .pod }}\"}"
        }
      }

      // embed as text property
      stage.match {
        selector = "{" + argument.__sd_annotation.value + "_embed_pod=~\"(?i)true\"} !~ \"^\\s*{(.|\n)+}\\s*$\""
        // render a new label called log_line, and add the name of the pod to the end of the log message
        // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
        // to the high cardinality it would create.
        // note: .Entry is a special key that is used to reference the current line
        stage.template {
          source = "log_line"
          template = "{{ .Entry }} " + argument.embed_pod_key.value + "={{ .pod }}"
        }
      }

      // reset the output to the log_line
      stage.output {
        source = "log_line"
      }
    }
  }
}

declare "mask" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "luhn_min_length" {
    comment = "The minimum length of a Luhn match to mask (default: 13)"
    default = 13
    optional = true
  }

  argument "luhn_text" {
    comment = "The replacement text to use to for Luhn matches (default: **LUHN*REDACTED**)"
    default = "**LUHN*REDACTED**"
    optional = true
  }

  argument "credit_card_text" {
    comment = "The replacement text to use to for Credit Card matches (default: **CC*REDACTED**)"
    default = "**CC*REDACTED**"
    optional = true
  }

  argument "email_text" {
    comment = "The replacement text to use to for Email matches (default: **EMAIL*REDACTED**)"
    default = "**EMAIL*REDACTED**"
    optional = true
  }

  argument "ipv4_text" {
    comment = "The replacement text to use to for IPv4 matches (default: **IPV4*REDACTED**)"
    default = "**IPV4*REDACTED**"
    optional = true
  }

  argument "ipv6_text" {
    comment = "The replacement text to use to for IPv6 matches (default: **IPV6*REDACTED**)"
    default = "**IPV6*REDACTED**"
    optional = true
  }

  argument "ssn_text" {
    comment = "The replacement text to use to for SSN matches (default: **SSN*REDACTED**)"
    default = "**SSN*REDACTED**"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "receiver" {
    value = loki.process.mask.receiver
  }

  loki.process "mask" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/mask-luhn annotation, if true the data will be masked as **LUHN*REDACTED**
    // https://en.wikipedia.org/wiki/Luhn_algorithm
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-luhn: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_luhn=~\"(?i)true\"}"

      stage.luhn {
        minLength = argument.luhn_min_length.value
        replacement = argument.luhn_text.value
      }
    }

    // check logs.grafana.com/mask-credit-card annotation, if true the data will be masked as **CC*REDACTED**
    // Formats:
    //   Visa: 4[0-9]{15}
    //   MasterCard: 5[1-5][0-9]{14}
    //   American Express: 3[47][0-9]{13}
    //   Discover: 6[0-9]{15}
    //   JCB: 3[51-55][0-9]{14}
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-credit-card: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_credit_card=~\"(?i)true\"}"

      stage.replace {
        // unescaped regex: (4[0-9]{15}|5[1-5][0-9]{14}|3[47][0-9]{13}|6[0-9]{15}|3[51-55][0-9]{14})
        expression = "(4[0-9]{15}|5[1-5][0-9]{14}|3[47][0-9]{13}|6[0-9]{15}|3[51-55][0-9]{14})"
        replace = argument.credit_card_text.value
      }
    }

    // check logs.grafana.com/mask-email annotation, if true the data will be masked as **EMAIL*REDACTED**
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-email: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_email=~\"(?i)true\"}"

      stage.replace {
        // unescaped regex: ([\w\.=-]+@[\w\.-]+\.[\w]{2,64})
        expression = "([\\w\\.=-]+@[\\w\\.-]+\\.[\\w]{2,64})"
        replace = argument.email_text.value
      }
    }

    // check logs.grafana.com/mask-ipv4 annotation, if true the data will be masked as **IPV4*REDACTED**
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-ipv4: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_ipv4=~\"(?i)true\"}"

      stage.replace {
        // unescaped regex: ((\b25[0-5]|\b2[0-4][0-9]|\b[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3})
        expression = "((\\b25[0-5]|\\b2[0-4][0-9]|\\b[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3})"
        replace = argument.ipv4_text.value
      }
    }

    // check logs.grafana.com/mask-ipv6 annotation, if true the data will be masked as **IPV6*REDACTED**
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-ipv6: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_ipv6=~\"(?i)true\"}"

      stage.replace {
        // unescaped regex: (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
        expression = "(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))"
        replace = argument.ipv6_text.value
      }
    }

    // check logs.grafana.com/mask-phone annotation, if true the data will be masked as **PHONE*REDACTED**
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-phone: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_phone=~\"(?i)true\"}"

      stage.replace {
        // unescaped regex: ([\+]?[(]?[0-9]{3}[)]?[-\s\.]?[0-9]{3}[-\s\.]?[0-9]{4,6})
        expression = "([\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6})"
        replace = argument.phone_text.value
      }
    }

    // check logs.grafana.com/mask-ssn annotation, if true the data will be masked as **SSN*REDACTED**
    stage.match {
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/mask-ssn: true"
      selector = "{" + argument.__sd_annotation.value + "_mask_ssn=~\"(?i)true\"}"

      stage.replace {
        // unescaped regex: ([0-9]{3}-[0-9]{2}-[0-9]{4})
        expression = "([0-9]{3}-[0-9]{2}-[0-9]{4})"
        replace = argument.ssn_text.value
      }
    }

  }
}

declare "trim" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "trim_value" {
    comment = "The regular expression to use to determine if whitespace should be embedded or not, if you want to embed the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.trim.receiver
  }

  loki.process "trim" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/trim annotation, if true trim any leading/trailing whitespace log line
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_trim=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/trim: true"

      stage.template {
        source = "trimmed_line"
        template = "{{ Trim .Entry }}"
      }

      stage.output {
        source = "trimmed_line"
      }
    }
  }
}

declare "dedup_spaces" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "trim_value" {
    comment = "The regular expression to use to determine if whitespace should be embedded or not, if you want to embed the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.dedup_spaces.receiver
  }

  loki.process "dedup_spaces" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/trim annotation, if true trim any leading/trailing whitespace log line
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_dedup_spaces=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/dedup-spaces: true"

      stage.replace {
        expression = "(\\s{2,})"
        replace    = " "
      }
    }
  }

}

declare "sampling" {
  argument "forward_to" {
    comment = "Must be a list(LogsReceiver) where collected logs should be forwarded to"
  }

  argument "annotation" {
    // Docs: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    // k8s selectors d not support a logical OR, if multiple types of annotations are needed, this module should be invoked multiple times
    // i.e. metrics.grafana.com, then again for prometheus.io
    comment = "The annotation namespace to use (default: logs.grafana.com)"
    default = "logs.grafana.com"
    optional = true
  }

  argument "sampling_value" {
    comment = "The regular expression to use to determine if the log should be sampled or not, if you want to sample the pod by default without setting the annotations everywhere use '.*' or 'true|' (default: true)"
    default = "true"
    optional = true
  }

  argument "sampling_rate" {
    comment = "The sampling rate in a range of [0, 1] (default: 0.25)"
    optional = true
    default = 0.25
  }

  argument "sampling_reason" {
    comment = "The sampling reason (default: annotation_sampling)"
    optional = true
    default = "annotation_sampling"
  }

  /*
    Hidden Arguments
    These arguments are used to set reusable variables to avoid repeating logic
  */
  argument "__sd_annotation" {
    optional = true
    comment = "The logic is used to transform the annotation argument into a valid label name by removing unsupported characters."
    default = replace(replace(replace(coalesce(argument.annotation.value, "logs.grafana.com"),".", "_"),"/", "_"),"-", "_")
  }

  export "annotation" {
    value = argument.annotation.value
  }

  export "receiver" {
    value = loki.process.sampling.receiver
  }

  loki.process "sampling" {
    forward_to = argument.forward_to.value

    // check logs.grafana.com/trim annotation, if true trim any leading/trailing whitespace log line
    stage.match {
      selector = "{" + argument.__sd_annotation.value + "_sampling=~\"" + argument.sampling_value.value + "\"}"
      pipeline_name = "pipeline for annotation || " + argument.annotation.value + "/sampling: true"

      stage.sampling {
        rate = argument.sampling_rate.value
        drop_counter_reason = argument.sampling_reason.value
      }
    }
  }

}
